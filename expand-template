#!/usr/bin/bash
#
# This script substitutes environment variables in shell format strings. It is
# a wrapper around `envsubst' and provides a number of convenient functions.
#

################################################################################
#                               CHECK ENVIRONMENT
################################################################################

# Make sure we will not mask or overwrite environment variables.
if [ -n "${!_d8e1_*}" ]; then
  echo "Error: no variable with the prefix \`_d8e1_'\ should exist in the environment!"
  printf "%s\n" "${!_d8e1_@}"
  exit 2
fi

# NOTE: Make sure to prefix the name of every global variable (including
#       non-local function variables), and local variables in functions that
#       modify environment variables.


################################################################################
#                                DEFAULT OPTIONS
################################################################################

# Report referenced variables that are missing (-m, --missing).
_d8e1_OPT_MISSING=0

# Do not expand missing variables (-n, --no-expand).
_d8e1_OPT_EXPAND=0

# Do not expand variables preceded by a backslash (-x, --escape).
_d8e1_OPT_ESCAPE=0

# Print a list of variable referenced and escaped (-s, --summary).
_d8e1_OPT_SUMMARY=0

# Print list of invalid escapings if any (-v, --verify).
_d8e1_OPT_CHECK=0


################################################################################
#                                 HANDLE OPTIONS
################################################################################

usage () {
  cat<<EOUSAGE
Usage:
  $(basename "$0") [OPTION]... <TEMPLATE> [DESTINATION]
  ... | $(basename "$0") [OPTION]... [DESTINATION]

Description:
  Substitutes the values of environment variables in place of shell format
  strings of the form \`\$var' and \`\${var}'. It uses \`envsubst' internally
  and adds a few convenient features to it, e.g. escaping support.

Arguments:
  TEMPLATE
    Template file to expand. Can be read from STDIN if not specified.

  DESTINATION
    Where to put the expanded template. In case the given path is as an existing
    directory, the output is saved in that directory. The filename is the
    template's filename, unless it ends with \`.tmpl' suffix in which case the
    suffix is removed. Otherwise the destination is interpreted as a file and
    the result is saved at the given path. Parent directories have to exist.
    Defaults to STDOUT.

Options:
  -c, --check
    Look for invalid escape sequences and exit.

  -e, --no-expand
    Do not expand variables that are not defined. Mutually exclusive with \`-m'.

  -m, --missing
    Report undefined variables and exit. Mutually exclusive with \`-e'.

  -s, --summary
    Print a list of referenced and escaped variables and exit.

  -x, --escape
    Allow escaping variable references with a backslash. See the \`Escaping'
    section below.

Escaping:
  Variable references can be escaped to prevent expansion using a slash \`\\'.

    $ export name=value
    $ echo '\\\$name' | $(basename "$0")
    \$name

  If a slash appears in a non-escping position, i.e. not immediately before a
  variable reference, it has to be escaped.

    $ echo 'text \\\\ text' | $(basename "$0")
    text \\ text

  When turning a file into template, it is recommended to first escape all
  slashes before inserting variable references.

    $ sed 's/\\\\/\\\\\\\\/g' < config.conf > config.tmpl

  Escaping slashes in the substituted values is not necessary.

Caveat:
  $(basename "$0") exits with an error when a variable starting with the prefix
  \`_d81e_' is declared in the environment. This is due to the fact that such
  variables are used internally and allowing them in the environment would cause
  incosistent behaviour and hard to find errors.

Exit status:
  The utility exits with 0 on success. When an error is detected the exit status
  is 1. When the internally used variable name prefix appears in the environment
  the utility exits with 2 (see \`Caveat' section).

See also:
  envsubst(1)

EOUSAGE
}

_d8e1_TEMP=$(getopt --options m,e,x,s,c \
                    --long missing,no-expand,escape,summary,check \
                    --name "$(basename "$0")" -- "$@")

if [ $? != 0 ]; then echo "Terminating..." >&2; exit 1; fi
eval set -- "$_d8e1_TEMP"

while true; do
  case "$1" in
    -m|--missing) _d8e1_OPT_MISSING=1; shift;;
    -e|--no-expand) _d8e1_OPT_EXPAND=1; shift;;
    -x|--escape) _d8e1_OPT_ESCAPE=1; shift;;
    -s|--summary) _d8e1_OPT_SUMMARY=1; shift;;
    -c|--check) _d8e1_OPT_CHECK=1; shift;;
    --) shift; break;;
    *) echo "Internal error!"; exit 1;;
  esac
done

# Options --missing and --no-expand are mutually exclusive.
if [ "$_d8e1_OPT_MISSING" -eq 1 ] && [ "$_d8e1_OPT_EXPAND" -eq 1 ]; then
  echo "Error: \`--missing' (-m) and \`--no-expand' (-e) cannot be specified at the same time!"
  exit 1
fi


################################################################################
#                                HANDLE ARGUMENTS
################################################################################

unset _d8e1_DEST
if tty -s <&0; then
  # Template read from file.
  if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    usage
    exit 1
  fi

  # If output is a directory, use the input file's name w/o the `.tmpl' suffix.
  if [ "$#" -eq 2 ]; then
    _d8e1_DEST="$([ -d "$2" ] && echo "$2/$(basename "${1%.tmpl}")" || echo "$2")"
  fi

  _d8e1_INPUT="$(cat "$1")"
else
  # Template read from STDIN.
  if [ "$#" -gt 1 ]; then
    usage
    exit 1
  fi

  if [ "$#" -eq 1 ]; then
    if [ -d "$1" ]; then
      echo "Error: destination cannot be a directory when reading the template from STDIN!"
      exit 1
    fi
    _d8e1_DEST="$1"
  fi

  _d8e1_INPUT="$(cat)"
fi


################################################################################
#                                   FUNCTIONS
################################################################################

# Outputs the list of variables referenced in the given template. The output
# contains one variable name per line, and can be directly captured into an
# array by the caller. For example:
#
#   vars=( "$(get_referenced "$input")" )
#
# Globals:
#   none
# Arguments:
#   $1 - template string
#   $2 - enable escaping [ 1, Yes ]
# Output:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_referenced () {
  local input="$1"
  local do_escape="${2:-1}"
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  local ref_vars
  if [ "$do_escape" == 1 ]; then
    ref_vars=( $(
      # 1. remove braces around variable names (${var} -> $var)
      # 2. surround non-escaped variable references with newlines ((even x \)$var -> \n(even x \)$var\n)
      # 3. select lines that contain only an escaped reference, w/o leading (even * \)$
      # 4. remove duplicates
      echo "$input" \
        | sed -r -e 's/\$\{('"${name}"')\}/$\1/g' \
                 -e 's/(^|[^\])(\\\\)*(\$'"${name}"')/\1\n\2\3\n/g' \
        | sed -nr 's/^(\\\\)*\$('"${name}"')$/\2/p' \
        | sort -u
      ) )
  else
    ref_vars=( $(
      # 1. remove braces around variable names (${var} -> $var)
      # 2. surround variable references with newlines ($var -> \n$var\n)
      # 3. select lines that contain only a reference, w/o leading $
      # 4. remove duplicates
      echo "$input" \
        | sed -r -e 's/\$\{('"${name}"')\}/$\1/g' \
                 -e 's/\$'"${name}"'/\n&\n/g' \
        | sed -nr 's/^\$('"${name}"')$/\1/p' \
        | sort -u
      ) )
  fi

  printf "%s\n" "${ref_vars[@]}"
  [ "${#ref_vars[@]}" -ne 0 ]
}

# Output the list of escaped variable references in the given template. The
# output contains one variable name per line, and can be directly captured into
# an array by the caller. For example:
#
#   vars=( "$(get_escaped "$input")" )
#
# Globals:
#   none
# Arguments:
#   $1 - template string
# Output:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_escaped () {
  local input="$1"
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  local esc_vars
  esc_vars=( $(
    # 1. remove braces around variable names (${var} -> $var)
    # 2. surround escaped variable references with newlines (\$var -> \n\$var\n)
    # 3. select lines that contain only an escaped reference, w/o leading \$
    # 4. remove duplicates
    echo "$input" \
      | sed -r -e 's/\$\{('"${name}"')\}/$\1/g' \
               -e 's/((^|[^\])(\\\\)*)(\\\$'"${name}"')/\1\n\4\n/g' \
      | sed -nr 's/^\\\$('"${name}"')$/\1/p' \
      | sort -u
    ) )

  printf "%s\n" "${esc_vars[@]}"
  [ "${#esc_vars[@]}" -ne 0 ]
}

# Outputs the list of variables referenced in the given template that are not
# defined in the environment. The output contains one variable name per line,
# and can be directly captured into an array by the caller. For example:
#
#   vars=( "$(get_missing "$input")" )
#
#
# Globals:
#   All environmental variables.
# Arguments:
#   $1 - template string
# Outputs:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_missing () {
  local input="$1"
  local temp_vars miss_vars
  ref_vars=( $(get_referenced "$input") )
  miss_vars=( $(comm -23 <(printf "%s\n" "${ref_vars[@]}") \
                         <(printf "%s\n" "$(compgen -e | sort)")) )
  printf "%s\n" "${miss_vars[@]}"
  [ "${#miss_vars[@]}" -ne 0 ]
}

# Outputs the list of variables referenced in the given template that are
# defined in the environment. Essentially producing the complement of
# `get_missing'. The output contains one variable name per line, and can be
# directly captured into an array by the caller. For example:
#
#   vars=( "$(get_defined "$input")" )
#
#
# Globals:
#   All environmental variables.
# Arguments:
#   $1 - template string
# Outputs:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_defined () {
  local input="$1"
  local temp_vars defined_vars

  ref_vars=( $(get_referenced "$input") )
  defined_vars=( $(comm -12 <(printf "%s\n" "${ref_vars[@]}") \
                            <(printf "%s\n" "$(compgen -e | sort)")) )
  printf "%s\n" "${defined_vars[@]}"
  [ "${#defined_vars[@]}" -ne 0 ]
}

# Escape the template string read from STDIN. This function is necessary before
# expanding.
#
# Globals:
#   none
# Arguments:
#   none
# Inputs:
#   STDIN - template string
# Outputs:
#   STDOUT - escaped text
# Returns:
#   0 - success
#   1 - otherwise
escape () {
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  # 1. (even x \)\$var   -> (even x \)$\var
  #    (even x \)$var    -x
  # 2. (even x \)\${var} -> (even x \)$\{var}
  #    (even x \)${var}  -x
  sed -r -e 's/((^|[^\])(\\\\)*)(\\)\$('"$name"')/\1$\4\5/g' \
         -e 's/((^|[^\])(\\\\)*)(\\)\$(\{'"$name"'\})/\1$\4\5/g'
}

# Un-escape the given string. This function is necessary after expanding.
#
# Globals:
#   none
# Arguments:
#   none
# Inputs:
#   STDIN - template string
# Outputs:
#   STDOUT - un-escaped text
# Returns:
#   0 - success
#   1 - otherwise
unescape () {
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  # 1. $\var -> $var
  # 2. $\{var} -> ${var}
  # 3. \\ -> \
  sed -r -e 's/(\$)\\('"${name}"')/\1\2/g' \
         -e 's/(\$)\\(\{'"${name}"'\})/\1\2/g' \
         -e 's/\\\\/\\/g'
}

# Escape slashes in the given environment variables.
#
# Globals:
#   none
# Arguments:
#   $@ - list of variables to escape
# Inputs:
#   none
# Outputs:
#   none
# Returns:
#   0 - success
#   1 - otherwise
escape_vars () {
  for _d8e1_var in $@; do
    # `\' -> `\\'
    eval "$_d8e1_var"'="${'"$_d8e1_var"'//\\/\\\\}"'
  done
}

# Check that all escape sequences are valid in the given template. Lines
# containing invalid escape sequences are printed along with their line numbers.
#
# Globals:
#   none
# Arguments:
#   $1 - template string
# Input:
#   none
# Outputs:
#   STDOUT - escaping errors with line numbers if any
# Returns:
#   0 - correct escaping
#   1 - otherwise
check_esc () {
  local input="$1"

  local error=0
  local line_no=0
  while read -r line; do
    : $((++line_no))
    # Mutually exclusive patterns matching:
    # 1. (odd * `\') + (not a `$')
    # 2. (odd * `\') + $ + (not a `{' or variable name character)
    # 3. (odd * `\') + ${ + (not a variable name character)
    # 4. (odd * `\') + ${ + (variable name characters) + (not a `}' or a variable name character)
    local match="$(echo "$line" \
      | sed -nr -e '/(^|[^\])(\\\\)*\\([^\$]|$)/p' \
                -e '/(^|[^\])(\\\\)*\\\$([^{a-zA-Z_]|$)/p' \
                -e '/(^|[^\])(\\\\)*\\\$\{([^a-zA-Z_]|$)/p' \
                -e '/(^|[^\])(\\\\)*\\\$\{[a-zA-Z_][a-zA-Z_0-9]*([^}a-zA-Z_0-9]|$)/p'
    )"
    if [ -n "$match" ]; then
      if [ "$error" -eq 0 ]; then
        echo 'Error: Invalid escaping in the following lines:'
        error=1
      fi
      echo "$line_no: $match"
    fi
  done <<< "$input"

  [ "$error" -eq 0 ] && echo 'Everything looks good!'
  return $error
}


################################################################################
#                                      MAIN
################################################################################

if [ "$_d8e1_OPT_SUMMARY" -eq 1 ]; then
  if [ "$_d8e1_OPT_ESCAPE" -eq 1 ]; then
    _d8e1_ESCAPED=( $(get_escaped "$_d8e1_INPUT") )
    if [ "$?" -eq 0 ]; then
      echo "Escaped variables:"
      printf "%s\n" "${_d8e1_ESCAPED[@]}"
    fi
  fi
  _d8e1_REFERENCED=( $(get_referenced "$_d8e1_INPUT" $_d8e1_OPT_ESCAPE) )
  if [ "$?" -eq 0 ]; then
    echo "Referenced variables:"
    printf "%s\n" "${_d8e1_REFERENCED[@]}"
  fi
  exit 0
fi

if [ "$_d8e1_OPT_CHECK" -eq 1 ]; then
  check_esc "$_d8e1_INPUT"
  exit $?
fi

if [ "$_d8e1_OPT_MISSING" -eq 1 ]; then
  _d8e1_MISS=( $(get_missing "$_d8e1_INPUT") )
  if [ "$?" -eq 0 ]; then
    echo "Error: the variables below are referenced but not defined!"
    printf "%s\n" "${_d8e1_MISS[@]}"
    exit 1
  fi
fi

unset _d8e1_SHELL_FORMAT
if [ "$_d8e1_OPT_EXPAND" -eq 1 ]; then
  _d8e1_DEFINED=( $(get_defined "$_d8e1_INPUT") )
  if [ "$?" -eq 0 ]; then
    _d8e1_SHELL_FORMAT="$(printf '$%s' "${_d8e1_DEFINED[@]}")"
  else
    _d8e1_SHELL_FORMAT="''"
  fi
fi

# Expand template.
# Not quoting `$SHELL_FORMAT' allows not passing the argument if it's not set.
if [ "$_d8e1_OPT_ESCAPE" -eq 1 ]; then
  escape_vars "$(get_defined "$_d8e1_INPUT")"
  _d8e1_OUTPUT="$(echo "$_d8e1_INPUT" \
                    | escape \
                    | envsubst $_d8e1_SHELL_FORMAT \
                    | unescape)"
else
  _d8e1_OUTPUT="$(echo "$_d8e1_INPUT" | envsubst $_d8e1_SHELL_FORMAT)"
fi

# Output
[ "${_d8e1_DEST:-x}" != 'x' ] && echo "$_d8e1_OUTPUT" > "$_d8e1_DEST" \
                              || echo "$_d8e1_OUTPUT"
