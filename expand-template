#!/usr/bin/bash
#
# This script substitutes environment variables in shell format strings. It is
# a wrapper around `envsubst' and provides a number of convenient functions.
#

################################################################################
#                                DEFAULT OPTIONS
################################################################################

# Report referenced variables that are missing (-m, --missing).
OPT_MISSING=0

# Do not expand missing variables (-n, --no-expand).
OPT_EXPAND=0


################################################################################
#                                 HANDLE OPTIONS
################################################################################

usage () {
  cat<<EOUSAGE
Usage:
  $(basename "$0") [options] <template> [destination]
  ... | $(basename "$0") [options] [destination]

Arguments:
  template   template file to expand, can be read from STDIN instead

Destination:
  Defaults to STDOUT if not specified.

  file   path of resulting file
  dir    path of directory for the resulting file, filename is set to the
         template's name minus \`.tmpl' suffix if exists

Options:
  -m, --missing     Report undefined variables and exit.
  -e, --no-expand   Do not expand variables that are not defined.
EOUSAGE
}

TEMP=$(getopt --options m,e \
              --long missing,no-expand \
              --name "$(basename "$0")" -- "$@")

if [ $? != 0 ]; then echo "Terminating..." >&2; exit 1; fi
eval set -- "$TEMP"

while true; do
  case "$1" in
    -m|--missing) OPT_MISSING=1; shift;;
    -e|--no-expand) OPT_EXPAND=1; shift;;
    --) shift; break;;
    *) echo "Internal error!"; exit 1;;
  esac
done


################################################################################
#                                HANDLE ARGUMENTS
################################################################################

unset OUTPUT
if tty -s <&0; then
  # Template read from file.
  if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    usage
    exit 1
  fi

  # If output is a directory, use the input file's name w/o the `.tmpl' suffix.
  if [ "$#" -eq 2 ]; then
    OUTPUT="$([ -d "$2" ] && echo "$2/$(basename "${1%.tmpl}")" || echo "$2")"
  fi

  INPUT="$(cat "$1")"
else
  # Template read from STDIN.
  if [ "$#" -gt 1 ]; then
    usage
    exit 1
  fi

  if [ "$#" -eq 1 ]; then
    if [ -d "$1" ]; then
      echo "Error: destination cannot be a directory when reading the template from STDIN!"
      exit 1
    fi
    OUTPUT="$1"
  fi

  INPUT="$(cat)"
fi


################################################################################
#                                   FUNCTIONS
################################################################################

# Outputs the list of variables referenced in the given template. The output
# contains one variable name per line, and can be directly captured into an
# array by the caller. For example:
#
#   vars=( "$(get_referenced "$input")" )
#
# Globals:
#   none
# Arguments:
#   $1 - template string
# Output:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_referenced () {
  local input="$1"
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  local ref_vars
  ref_vars=( $(
    # 1. remove braces around variable names \
    # 2. surround variable references with newlines \
    # 3. output variable references only w/o leading $
    # 4. remove duplicates
    echo "$input" \
      | sed -r -e "s/\\\$\{(${name})\}/$\1/g" \
               -e "s/\\\$${name}/\n&\n/g" \
      | sed -nr "s/\\\$(${name})/\1/p" \
      | sort -u
    ) )

  printf "%s\n" "${ref_vars[@]}"
  [ "${#ref_vars[@]}" -ne 0 ]
}

# Outputs the list of variables referenced in the given template that are not
# defined in the environment. The output contains one variable name per line,
# and can be directly captured into an array by the caller. For example:
#
#   vars=( "$(get_missing "$input")" )
#
#
# Globals:
#   All environmental variables.
# Arguments:
#   $1 - template string
# Outputs:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_missing () {
  local input="$1"
  local temp_vars miss_vars
  temp_vars=( $(get_referenced "$input") )
  miss_vars=( $(comm -23 <(printf "%s\n" "${temp_vars[@]}") \
                         <(printf "%s\n" "$(compgen -e | sort)")) )
  printf "%s\n" "${miss_vars[@]}"
  [ "${#miss_vars[@]}" -ne 0 ]
}

# Outputs the list of variables referenced in the given template that are
# defined in the environment. Essentially producing the complement of
# `get_missing'. The output contains one variable name per line, and can be
# directly captured into an array by the caller. For example:
#
#   vars=( "$(get_defined "$input")" )
#
#
# Globals:
#   All environmental variables.
# Arguments:
#   $1 - template string
# Outputs:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_defined () {
  local input="$1"
  local temp_vars defined_vars
  
  temp_vars=( $(get_referenced "$input") )
  defined_vars=( $(comm -12 <(printf "%s\n" "${temp_vars[@]}") \
                            <(printf "%s\n" "$(compgen -e | sort)")) )
  printf "%s\n" "${defined_vars[@]}"
  [ "${#defined_vars[@]}" -ne 0 ]
}


################################################################################
#                                      MAIN
################################################################################

if [ "$OPT_MISSING" -eq 1 ]; then
  MISS=( $(get_missing "$INPUT") )
  if [ "$?" -eq 0 ]; then
    echo "Error: the variables below are referenced but not defined!"
    printf "%s\n" "${MISS[@]}"
    exit 1
  fi
fi

unset SHELL_FORMAT
if [ "$OPT_EXPAND" -eq 1 ]; then
  DEFINED=( $(get_defined "$INPUT") )
  [ "${#DEFINED[@]}" -gt 0 ] && SHELL_FORMAT="$(printf '$%s' "${DEFINED[@]}")" \
                             || SHELL_FORMAT="''"
fi

# Expand template.
if [ "${OUTPUT:-x}" != 'x' ]; then
  # Not quoting `$SHELL_FORMAT' allows not passing the argument if it's not set.
  echo "$INPUT" | envsubst $SHELL_FORMAT > "$OUTPUT"
else
  # Not quoting `$SHELL_FORMAT' allows not passing the argument if it's not set.
  echo "$INPUT" | envsubst $SHELL_FORMAT
fi
