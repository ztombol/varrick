#!/usr/bin/bash

# Outputs the list of variables referenced in the given template. The output
# contains one variable name per line, and can be directly captured into an
# array by the caller. For example:
#
#   vars=( "$(get_referenced "$input")" )
#
# Globals:
#   none
# Arguments:
#   $1 - template string
#   $2 - enable escaping [ 1, Yes ]
# Output:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_referenced () {
  local input="$1"
  local do_escape="${2:-1}"
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  local ref_vars
  if [ "$do_escape" == 1 ]; then
    # FIXME(ztombol): Removing braces can cause problems if [a-zA-Z_0-9] follows
    #                 the reference. For example `${var}s ...' will refer to
    #                 `$vars' instead of `$var'.
    ref_vars=( $(
      # 1. remove braces around variable names (${var} -> $var)
      # 2. surround non-escaped variable references with newlines ((even x \)$var -> \n(even x \)$var\n)
      # 3. select lines that contain only an escaped reference, w/o leading (even * \)$
      # 4. remove duplicates
      echo "$input" \
        | sed -r -e 's/\$\{('"${name}"')\}/$\1/g' \
                 -e 's/(^|[^\])(\\\\)*(\$'"${name}"')/\1\n\2\3\n/g' \
        | sed -nr 's/^(\\\\)*\$('"${name}"')$/\2/p' \
        | sort -u
      ) )
  else
    # FIXME(ztombol): Removing braces can cause problems if [a-zA-Z_0-9] follows
    #                 the reference. For example `${var}s ...' will refer to
    #                 `$vars' instead of `$var'.
    ref_vars=( $(
      # 1. remove braces around variable names (${var} -> $var)
      # 2. surround variable references with newlines ($var -> \n$var\n)
      # 3. select lines that contain only a reference, w/o leading $
      # 4. remove duplicates
      echo "$input" \
        | sed -r -e 's/\$\{('"${name}"')\}/$\1/g' \
                 -e 's/\$'"${name}"'/\n&\n/g' \
        | sed -nr 's/^\$('"${name}"')$/\1/p' \
        | sort -u
      ) )
  fi

  printf "%s\n" "${ref_vars[@]}"
  [ "${#ref_vars[@]}" -ne 0 ]
}

# Output the list of escaped variable references in the given template. The
# output contains one variable name per line, and can be directly captured into
# an array by the caller. For example:
#
#   vars=( "$(get_escaped "$input")" )
#
# Globals:
#   none
# Arguments:
#   $1 - template string
# Output:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_escaped () {
  local input="$1"
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  local esc_vars
  esc_vars=( $(
    # FIXME(ztombol): Removing braces can cause problems if [a-zA-Z_0-9] follows
    #                 the reference. For example `${var}s ...' will refer to
    #                 `$vars' instead of `$var'.
    # 1. remove braces around variable names (${var} -> $var)
    # 2. surround escaped variable references with newlines (\$var -> \n\$var\n)
    # 3. select lines that contain only an escaped reference, w/o leading \$
    # 4. remove duplicates
    echo "$input" \
      | sed -r -e 's/\$\{('"${name}"')\}/$\1/g' \
               -e 's/((^|[^\])(\\\\)*)(\\\$'"${name}"')/\1\n\4\n/g' \
      | sed -nr 's/^\\\$('"${name}"')$/\1/p' \
      | sort -u
    ) )

  printf "%s\n" "${esc_vars[@]}"
  [ "${#esc_vars[@]}" -ne 0 ]
}

# Outputs the list of variables referenced in the given template that are not
# defined in the environment. The output contains one variable name per line,
# and can be directly captured into an array by the caller. For example:
#
#   vars=( "$(get_missing "$input")" )
#
#
# Globals:
#   All environmental variables.
# Arguments:
#   $1 - template string
# Outputs:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_missing () {
  local input="$1"
  local temp_vars miss_vars
  ref_vars=( $(get_referenced "$input") )
  miss_vars=( $(comm -23 <(printf "%s\n" "${ref_vars[@]}") \
                         <(printf "%s\n" "$(compgen -e | sort)")) )
  printf "%s\n" "${miss_vars[@]}"
  [ "${#miss_vars[@]}" -ne 0 ]
}

# Outputs the list of variables referenced in the given template that are
# defined in the environment. Essentially producing the complement of
# `get_missing'. The output contains one variable name per line, and can be
# directly captured into an array by the caller. For example:
#
#   vars=( "$(get_defined "$input")" )
#
#
# Globals:
#   All environmental variables.
# Arguments:
#   $1 - template string
# Outputs:
#   STDOUT - variable names separated by newlines
# Returns:
#   0 - list is not empty
#   1 - otherwise
get_defined () {
  local input="$1"
  local temp_vars defined_vars

  ref_vars=( $(get_referenced "$input") )
  defined_vars=( $(comm -12 <(printf "%s\n" "${ref_vars[@]}") \
                            <(printf "%s\n" "$(compgen -e | sort)")) )
  printf "%s\n" "${defined_vars[@]}"
  [ "${#defined_vars[@]}" -ne 0 ]
}

# Escape the template string read from STDIN. This function is necessary before
# expanding.
#
# Globals:
#   none
# Arguments:
#   none
# Inputs:
#   STDIN - template string
# Outputs:
#   STDOUT - escaped text
# Returns:
#   0 - success
#   1 - otherwise
escape () {
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  # 1. (even x \)\$var   -> (even x \)$\var
  #    (even x \)$var    -x
  # 2. (even x \)\${var} -> (even x \)$\{var}
  #    (even x \)${var}  -x
  sed -r -e 's/((^|[^\])(\\\\)*)(\\)\$('"$name"')/\1$\4\5/g' \
         -e 's/((^|[^\])(\\\\)*)(\\)\$(\{'"$name"'\})/\1$\4\5/g'
}

# Un-escape the given string. This function is necessary after expanding.
#
# Globals:
#   none
# Arguments:
#   none
# Inputs:
#   STDIN - template string
# Outputs:
#   STDOUT - un-escaped text
# Returns:
#   0 - success
#   1 - otherwise
unescape () {
  local name='[a-zA-Z_][a-zA-Z_0-9]*'

  # 1. $\var -> $var
  # 2. $\{var} -> ${var}
  # 3. \\ -> \
  sed -r -e 's/(\$)\\('"${name}"')/\1\2/g' \
         -e 's/(\$)\\(\{'"${name}"'\})/\1\2/g' \
         -e 's/\\\\/\\/g'
}

# Escape slashes in the given environment variables.
#
# Globals:
#   none
# Arguments:
#   $@ - list of variables to escape
# Inputs:
#   none
# Outputs:
#   none
# Returns:
#   0 - success
#   1 - otherwise
escape_vars () {
  for _d8e1_var in $@; do
    # `\' -> `\\'
    eval "$_d8e1_var"'="${'"$_d8e1_var"'//\\/\\\\}"'
  done
}

# Check that all escape sequences are valid in the given template. Lines
# containing invalid escape sequences are printed along with their line numbers.
#
# Globals:
#   none
# Arguments:
#   $1 - template string
# Input:
#   none
# Outputs:
#   STDOUT - escaping errors with line numbers if any
# Returns:
#   0 - correct escaping
#   1 - otherwise
check_esc () {
  local input="$1"

  local error=0
  local line_no=0
  while read -r line; do
    : $((++line_no))
    # Mutually exclusive patterns matching:
    # 1. (odd * `\') + (not a `$')
    # 2. (odd * `\') + $ + (not a `{' or variable name character)
    # 3. (odd * `\') + ${ + (not a variable name character)
    # 4. (odd * `\') + ${ + (variable name characters) + (not a `}' or a variable name character)
    local match="$(echo "$line" \
      | sed -nr -e '/(^|[^\])(\\\\)*\\([^\$]|$)/p' \
                -e '/(^|[^\])(\\\\)*\\\$([^{a-zA-Z_]|$)/p' \
                -e '/(^|[^\])(\\\\)*\\\$\{([^a-zA-Z_]|$)/p' \
                -e '/(^|[^\])(\\\\)*\\\$\{[a-zA-Z_][a-zA-Z_0-9]*([^}a-zA-Z_0-9]|$)/p'
    )"
    if [ -n "$match" ]; then
      if [ "$error" -eq 0 ]; then
        echo 'Error: Invalid escaping in the following lines:'
        error=1
      fi
      echo "$line_no: $match"
    fi
  done <<< "$input"

  [ "$error" -eq 0 ] && echo 'Everything looks good!'
  return $error
}
