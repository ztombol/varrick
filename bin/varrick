#!/usr/bin/bash
#
# This script substitutes environment variables in shell format strings. It is
# a wrapper around `envsubst' and provides a number of convenient functions.
#

################################################################################
#                               CHECK ENVIRONMENT
################################################################################

# Make sure we will not mask or overwrite environment variables.
if [ -n "${!_d8e1_*}" ]; then
  echo "Error: no variable with the prefix \`_d8e1_'\ should exist in the environment!"
  printf "%s\n" "${!_d8e1_@}"
  exit 2
fi

# NOTE: Make sure to prefix the name of every global variable (including
#       non-local function variables), and local variables in functions that
#       modify environment variables.


################################################################################
#                                DEFAULT OPTIONS
################################################################################

# Report referenced variables that are missing (-m, --missing).
_d8e1_OPT_MISSING=0

# Do not expand missing variables (-n, --no-expand).
_d8e1_OPT_EXPAND=0

# Do not expand variables preceded by a backslash (-x, --escape).
_d8e1_OPT_ESCAPE=0

# Print a list of variable referenced and escaped (-s, --summary).
_d8e1_OPT_SUMMARY=0

# Print list of invalid escapings if any (-v, --verify).
_d8e1_OPT_CHECK=0


################################################################################
#                                 HANDLE OPTIONS
################################################################################

print_version () {
  local version='0.1.0'
  echo "Varrick v$version"
}

print_usage () {
  cat<<EOUSAGE
$(print_version)
Usage: varrick [OPTION]... <TEMPLATE> [DESTINATION]
       ... | varrick [OPTION]... [DESTINATION]
See \`varrick --help' for more.
EOUSAGE
}
print_help () {
  cat<<EOHELP
$(print_version)
Usage:
  varrick [OPTION]... <TEMPLATE> [DESTINATION]
  ... | varrick [OPTION]... [DESTINATION]

Description:
  Substitutes the values of environment variables in place of shell format
  strings of the form \`\$var' and \`\${var}'. It uses \`envsubst' internally
  and adds a few convenient features to it, e.g. escaping support.

Arguments:
  TEMPLATE
    Template file to expand. Can be read from STDIN if not specified.

  DESTINATION
    Where to put the expanded template. In case the given path is as an existing
    directory, the output is saved in that directory. The filename is the
    template's filename, unless it ends with \`.tmpl' suffix in which case the
    suffix is removed. Otherwise the destination is interpreted as a file and
    the result is saved at the given path. Parent directories have to exist.
    Defaults to STDOUT.

Options:
  -c, --check
    Look for invalid escape sequences and exit.

  -e, --no-expand
    Do not expand variables that are not defined. Mutually exclusive with \`-m'.

  -m, --missing
    Report undefined variables and exit. Mutually exclusive with \`-e'.

  -s, --summary
    Print a list of referenced and escaped variables and exit.

  -x, --escape
    Allow escaping variable references with a backslash. See the \`Escaping'
    section below.

Escaping:
  Variable references can be escaped to prevent expansion using a slash \`\\'.

    $ export name=value
    $ echo '\\\$name' | varrick
    \$name

  If a slash appears in a non-escping position, i.e. not immediately before a
  variable reference, it has to be escaped.

    $ echo 'text \\\\ text' | varrick
    text \\ text

  When turning a file into template, it is recommended to first escape all
  slashes before inserting variable references.

    $ sed 's/\\\\/\\\\\\\\/g' < config.conf > config.tmpl

  Escaping slashes in the substituted values is not necessary.

Caveat:
  varrick exits with an error when a variable starting with the prefix
  \`_d81e_' is declared in the environment. This is due to the fact that such
  variables are used internally and allowing them in the environment would cause
  incosistent behaviour and hard to find errors.

Exit status:
  The utility exits with 0 on success. When an error is detected the exit status
  is 1. When the internally used variable name prefix appears in the environment
  the utility exits with 2 (see \`Caveat' section).

See also:
  envsubst(1)

EOHELP
}

_d8e1_TEMP=$(getopt --options c,e,h,m,s,u,v,x \
                    --long check,escape,help,missing,no-expand,summary,usage,version \
                    --name "varrick" -- "$@")

if [ $? != 0 ]; then echo "Terminating..." >&2; exit 1; fi
eval set -- "$_d8e1_TEMP"

while true; do
  case "$1" in
    -c|--check) _d8e1_OPT_CHECK=1; shift;;
    -e|--no-expand) _d8e1_OPT_EXPAND=1; shift;;
    -h|--help) print_help; exit 0; shift;;
    -m|--missing) _d8e1_OPT_MISSING=1; shift;;
    -s|--summary) _d8e1_OPT_SUMMARY=1; shift;;
    -u|--usage) print_usage; exit 0; shift;;
    -v|--version) print_version; exit 0; shift;;
    -x|--escape) _d8e1_OPT_ESCAPE=1; shift;;
    --) shift; break;;
    *) echo "Internal error!"; exit 1;;
  esac
done

# Options --missing and --no-expand are mutually exclusive.
if [ "$_d8e1_OPT_MISSING" -eq 1 ] && [ "$_d8e1_OPT_EXPAND" -eq 1 ]; then
  echo "Error: \`--missing' (-m) and \`--no-expand' (-e) cannot be specified at the same time!"
  exit 1
fi


################################################################################
#                                HANDLE ARGUMENTS
################################################################################

unset _d8e1_DEST
if tty -s <&0; then
  # Template read from file.
  if [ "$#" -lt 1 ] || [ "$#" -gt 2 ]; then
    print_usage
    exit 1
  fi

  # If output is a directory, use the input file's name w/o the `.tmpl' suffix.
  if [ "$#" -eq 2 ]; then
    _d8e1_DEST="$([ -d "$2" ] && echo "$2/$(basename "${1%.tmpl}")" || echo "$2")"
  fi

  if [ ! -e "$1" ]; then
    echo "Error: no such file \`$1'"
    exit 1
  fi
  _d8e1_INPUT="$(cat "$1")"
else
  # Template read from STDIN.
  if [ "$#" -gt 1 ]; then
    print_usage
    exit 1
  fi

  if [ "$#" -eq 1 ]; then
    if [ -d "$1" ]; then
      echo "Error: destination cannot be a directory when reading the template from STDIN!"
      exit 1
    fi
    _d8e1_DEST="$1"
  fi

  _d8e1_INPUT="$(cat)"
fi



################################################################################
#                                      MAIN
################################################################################

# Load libraries.
_d8e1_LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../lib/varrick" && pwd)"
. "$_d8e1_LIB_DIR/zhu-li.sh"

if [ "$_d8e1_OPT_SUMMARY" -eq 1 ]; then
  if [ "$_d8e1_OPT_ESCAPE" -eq 1 ]; then
    _d8e1_ESCAPED=( $(get_escaped "$_d8e1_INPUT") )
    if [ "$?" -eq 0 ]; then
      echo "Escaped variables:"
      printf "%s\n" "${_d8e1_ESCAPED[@]}"
    fi
  fi
  _d8e1_REFERENCED=( $(get_referenced "$_d8e1_INPUT" $_d8e1_OPT_ESCAPE) )
  if [ "$?" -eq 0 ]; then
    echo "Referenced variables:"
    printf "%s\n" "${_d8e1_REFERENCED[@]}"
  fi
  exit 0
fi

if [ "$_d8e1_OPT_CHECK" -eq 1 ]; then
  check_esc "$_d8e1_INPUT"
  exit $?
fi

if [ "$_d8e1_OPT_MISSING" -eq 1 ]; then
  _d8e1_MISS=( $(get_missing "$_d8e1_INPUT") )
  if [ "$?" -eq 0 ]; then
    echo "Error: the variables below are referenced but not defined!"
    printf "%s\n" "${_d8e1_MISS[@]}"
    exit 1
  fi
fi

unset _d8e1_SHELL_FORMAT
if [ "$_d8e1_OPT_EXPAND" -eq 1 ]; then
  _d8e1_DEFINED=( $(get_defined "$_d8e1_INPUT") )
  if [ "$?" -eq 0 ]; then
    _d8e1_SHELL_FORMAT="$(printf '$%s' "${_d8e1_DEFINED[@]}")"
  else
    _d8e1_SHELL_FORMAT="''"
  fi
fi

# Expand template.
# Not quoting `$SHELL_FORMAT' allows not passing the argument if it's not set.
if [ "$_d8e1_OPT_ESCAPE" -eq 1 ]; then
  escape_vars "$(get_defined "$_d8e1_INPUT")"
  _d8e1_OUTPUT="$(echo "$_d8e1_INPUT" \
                    | escape \
                    | envsubst $_d8e1_SHELL_FORMAT \
                    | unescape)"
else
  _d8e1_OUTPUT="$(echo "$_d8e1_INPUT" | envsubst $_d8e1_SHELL_FORMAT)"
fi

# Output
[ "${_d8e1_DEST:-x}" != 'x' ] && echo "$_d8e1_OUTPUT" > "$_d8e1_DEST" \
                              || echo "$_d8e1_OUTPUT"
